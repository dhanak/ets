<%doc> This is a -*- mason -*- template.
Handler of the Prolog Enumeration Sequence (PSEQ) scheme.
</%doc>
<%method longname>Prolog megoldások sorrendje</%method>

<%args> $exdata </%args>

Tegyük fel, hogy az alábbi programot betöltöttük a SICStus Prolog
rendszerbe. Állapítsd meg, hogy a feltett kérdésre válaszul a rendszer
milyen behelyettesítést ad az adott változónak!
% if (!$exdata->{ONESOL}) {
Sorold fel az összes megoldást, a rendszer által előállított sorrendben és
írd le ezeket pontosvesszővel elválasztva! Ha nincs megoldás, írj
<code>{no}</code>-t!
% }
<P>A program:
<PRE><% $m->comp('/sub/get_script', $exdata->{SCRIPT}) %></PRE>
<P>A kérdés:
<PRE>| ?- <% $exdata->{QUERY} %>.</PRE>
<P>Add meg <CODE><% $exdata->{VAR} %></CODE>
<% $exdata->{ONESOL} ? "értékét" : "értékeit" %>!

<%method helpref>
<%args>
$category
</%args>
<%init>;
return "hints?topic=PSEQ/$category";
</%init>

</%method>

<%method answers>
<%args>
$exdata
$sol => ""
</%args>
<INPUT TYPE=text NAME=sol SIZE=60 VALUE="<% $sol %>">
</%method>

<%method check>
<%args>
$exdata
$sol
</%args>
<%init>;
my ($input, $ret, $msg) = ("/tmp/$sid.pl");
open PL, ">$input";
print PL $m->comp('/sub/get_script', $exdata->{SCRIPT});
close PL;
($ret, $msg) = $m->comp('sub/prolog_script', script => "pseq_check",
			args => [ $input,
				  "$exdata->{VAR} - ($exdata->{QUERY})",
				  $sol
				  ]);
unlink $input;
return ($ret == 1) ? undef : $msg;
</%init>
</%method>

<%method errstr>
<%args>
$exdata
$error
</%args>
<% $error %>
</%method>

<%method describe>
<%args>
$exdata
</%args>
<% $exdata->{QUERY} %>. <% $exdata->{VAR} %> = ?
</%method>

<%method params>
<%args>
$exdata
</%args>
<TABLE>
<TR><TD>A program:
    <TD><& script_combo, name => "script", selected => $exdata->{SCRIPT} &>
<TR><TD>A hívás:
    <TD><INPUT TYPE=text NAME=query SIZE=50 VALUE="<% $exdata->{QUERY} %>">
<TR><TD>A kérdéses változó:
    <TD><INPUT TYPE=text NAME=var SIZE=3 VALUE="<% $exdata->{VAR} %>">
<INPUT TYPE=checkbox NAME=onesol <% $exdata->{ONESOL} ? "checked" : "" %>>
    Pontosan egy megoldást kérek
</TABLE>
</%method>

<%method calcdata>
<%args>
$script
$query
$var
$onesol => undef
</%args>
<%init>;
my ($input, $output, %data) = ("/tmp/$sid.pl");
my $pl_timeout = $ENV{ETS_ROOT} . "/bin/timeout_pl.pl";

$data{SCRIPT} = $script;
$data{QUERY} = $query;
$data{VAR} = $var;
$data{ONESOL} = $onesol ? 1 : 0;

open PL, ">$input";
print PL $m->comp('/sub/get_script', $script);
print PL ":- $query.\n:- halt.\n";
close PL;
open Reader, "$pl_timeout $input |";
$output = join "", <Reader>;
close Reader;
unlink $input;

$output =~ s/^[^!].*\n//mg;
chomp $output;
if ($output) {
    return { %data, ERROR => "<PRE>$output</PRE>" };
} else {
    return { %data };
}
</%init>
</%method>
