<%doc> This is a -*- mason -*- template.
Handler of the SML Expression Value (SVAL) scheme.
</%doc>
<%method longname>SML mi-az-értéke</%method>

<%args> $exdata </%args>

Mi az értéke az alábbi SML kifejezésnek?  A helyes válasznak azt a
legegyszerűbb alakját add meg, amelyet az MOSML értelmező is ad.  (A végére
ne írj pontosvesszőt!)
<BR>
% if (defined $exdata->{PREDEC}) {
<PRE><% $exdata->{PREDEC} %>;</PRE>;
% }
<PRE>- <% $exdata->{EXPR} %>;</PRE>

<%method answers>
<%args>
$exdata
$result => ""
</%args>
<CODE>&gt; val it = </CODE>
% $result =~ s/"/&quot;/g;
<INPUT TYPE=text NAME=result size=60 VALUE="<% $result %>">
</%method>

<%method check>
<%args>
$exdata
$result
</%args>
<%init>
my ($input, $output) = ("/tmp/$sid.sml");
my $mosml_timeout = $ENV{ETS_ROOT} . "/bin/timeout_sml.pl";

# Check answer syntactically and canonically
open SML, ">$input";
print SML "val result = " . $result . ";\n";
close SML;
open Reader, "$mosml_timeout $input |";
$output = join "", <Reader>;
close Reader;
if ($output eq "TIMEOUT") {
    unlink $input;
    return ["TIMEOUT"];
} elsif ($output =~ /! Toplevel/) {
    unlink $input;
    return ["SYNERROR", $output];
}
$result =~ s/ +//g;
($output) = ($output =~ /val.* result = (.*) : /);
$output =~ s/ +//g;
if ($output ne $result) {
    unlink $input;
    return ["CANERROR"];
}
	 
# Add original expression and compare with answer
open SML, ">>$input";
print SML <<EOF;
$exdata->{PREDEC};
val _ = print (if $exdata->{EXPR} = result then "%%% OK %%%" else "%%% NO %%%");
EOF
close SML;
open Reader, "$mosml_timeout $input |";
$output = join "", <Reader>;
close Reader;
unlink $input;
if ($output eq "TIMEOUT") {
    return ["TIMEOUT"];
} elsif ($output =~ /! Toplevel/) {
    $output =~ s/^.*! Type clash/! Type clash/s;
    return ["TYPERROR", $output];
} elsif ($output =~ /%%% NO %%%/) {
    return ["ERROR"];
}
return undef;
</%init>
</%method>

<%method errstr>
<%args>
$exdata
$error
</%args>
% if ($error->[0] eq "TIMEOUT") {
Időtúllépés (végtelen ciklus?)
% } elsif ($error->[0] eq "SYNERROR") {
Szintaktikai hiba:<BR>
<PRE><% $error->[1] %></PRE>
% } elsif ($error->[0] eq "CANERROR") {
Ezt ennél egyszerűbben is fel lehet írni!
% } elsif ($error->[0] eq "TYPERROR") {
A válasz típusa nem egyezik meg a kifejezés típusával:
<PRE><% $error->[1] %></PRE>
% } elsif ($error->[0] eq "ERROR") {
Nem ez a jó válasz.
% }
</%method>

<%method describe>
<%args>
$exdata
</%args>
% if (defined $exdata->{PREDEC}) {
<% $exdata->{PREDEC} %>;
% }
<% $exdata->{EXPR} %> = ?
</%method>

<%method params>
<%args>
$exdata
</%args>
Előzetes deklaráció (maradhat üres):<BR>
<TEXTAREA NAME=predec ROWS=5 COLS=50><% $exdata->{PREDEC} %></TEXTAREA>
<P>Az SML kifejezés:<BR>
<TEXTAREA NAME=expr ROWS=5 COLS=50><% $exdata->{EXPR} %></TEXTAREA>
</%method>

<%method calcdata>
<%args>
$predec
$expr
</%args>
<%init>
my ($input, $output, %data) = ("/tmp/$sid.sml");
my $mosml_timeout = $ENV{ETS_ROOT} . "/bin/timeout_sml.pl";

$data{EXPR} = $expr;
$data{PREDEC} = $predec if $predec ne "";

open SML, ">$input";
print SML "$predec;\n$expr\n";
close SML;
open Reader, "$mosml_timeout $input |";
$output = join "", <Reader>;
close Reader;
unlink $input;

if ($output =~ /! Toplevel/) {
    chomp $output;
    return { %data, ERROR => "<PRE>$output</PRE>" };
} else {
    return \%data;
}
</%init>
</%method>
